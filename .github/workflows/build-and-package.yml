name: Build and Package

# This workflow builds the Blackhole Sim application for both Intel (x86_64) and Apple Silicon (arm64)
# architectures and uploads to the App Store Connect.
#
# Triggers:
#   - Tags matching 'prod-v*' pattern (e.g., prod-v1.0.0) - builds and uploads to App Store
#   - Manual workflow dispatch (can specify version via input)
#
# Version Handling:
#   - Tag format: prod-v<VERSION> (e.g., prod-v1.0.0 extracts version "1.0.0")
#   - Version is used in app bundle Info.plist and App Store metadata
#   - Default version for manual builds: 1.0
#
# Outputs:
#   - .itmsp package automatically uploaded to App Store Connect
#   - DMG files created as workflow artifacts (for testing/backup only)
#
# Note: Code signing is enabled if MACOS_CERTIFICATE and MACOS_CERTIFICATE_PASSWORD secrets are configured.
# To set up signing:
#   1. Export your App Store certificate (Apple Distribution or 3rd Party Mac Developer Application) as a .p12 file
#   2. Base64 encode it: base64 -i YourCertificate.p12 | pbcopy
#   3. Add it as a GitHub secret: MACOS_CERTIFICATE
#   4. Add the certificate password as another secret: MACOS_CERTIFICATE_PASSWORD
#
# Notarization is DISABLED for App Store builds (the App Store handles this during review).
# Notarization is only needed for apps distributed outside the App Store (DMG downloads).
#
# App Store Connect upload is enabled if MACOS_INSTALLER_CERTIFICATE, MACOS_INSTALLER_CERTIFICATE_PASSWORD,
# TRANSPORTER_APPLE_ID, and TRANSPORTER_PASSWORD secrets are configured.
# To set up App Store upload:
#   1. Export your Mac Installer Distribution certificate as a .p12 file
#   2. Base64 encode it: base64 -i MacInstallerDistribution.p12 | pbcopy
#   3. Add it as a GitHub secret: MACOS_INSTALLER_CERTIFICATE
#   4. Add the certificate password as another secret: MACOS_INSTALLER_CERTIFICATE_PASSWORD
#   5. Create an app-specific password at appleid.apple.com
#   6. Add your Apple ID as secret: TRANSPORTER_APPLE_ID
#   7. Add the app-specific password as secret: TRANSPORTER_PASSWORD

on:
  push:
    # branches:
    #   - main
    tags:
      - "prod-v*" # Trigger on production tags like prod-v1.0.0
  workflow_dispatch: # Allow manual triggering
    inputs:
      version:
        description: "Version number (e.g., 1.0.0)"
        required: false
        type: string

jobs:
  build:
    strategy:
      matrix:
        # x86_64 builds are commented out to save time and cost
        # Uncomment the line below and the x86_64 include entry to enable Intel builds
        arch: [arm64] # , x86_64]
        include:
          - arch: arm64
            runner: macos-14
            triplet: arm64-osx
          # - arch: x86_64
          #   runner: macos-13
          #   triplet: x64-osx

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for tags

      - name: Extract version from tag
        id: version
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]] && [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
            # Extract version from tag (everything after prod-v)
            VERSION="${BASH_REMATCH[1]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Extracted version from tag: $VERSION"
          elif [[ -n "${{ inputs.version }}" ]]; then
            # Use version from workflow_dispatch input
            VERSION="${{ inputs.version }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Using version from input: $VERSION"
          else
            # Default version for branch builds
            VERSION="1.0"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Using default version: $VERSION"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      # Check for Transporter EARLY (before build) to fail fast if not available
      # This saves time by detecting the issue before the long vcpkg build process
      - name: Check for Transporter (early validation)
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        id: check_transporter_early
        run: |
          echo "üîç Checking for Transporter/iTMSTransporter (early validation)..."
          echo "   This check runs before the build to fail fast if Transporter is missing"

          # Function to check if transporter exists at a path
          check_transporter() {
            if [ -f "$1" ] && [ -x "$1" ]; then
              echo "‚úÖ Found iTMSTransporter: $1"
              echo "transporter_path=$1" >> $GITHUB_OUTPUT
              echo "transporter_available=true" >> $GITHUB_OUTPUT
              return 0
            fi
            return 1
          }

          # 1. Check if Transporter.app is installed
          if check_transporter "/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter"; then
            exit 0
          fi

          # 2. Check Xcode paths more thoroughly
          echo "Checking Xcode installation..."
          XCODE_PATH=$(xcode-select -p 2>/dev/null || echo "")
          if [ -z "$XCODE_PATH" ]; then
            echo "‚ö†Ô∏è  Xcode not found via xcode-select"
          else
            echo "‚úÖ Xcode path: $XCODE_PATH"
          fi
          
          # Try using xcrun to find Transporter (if available)
          if command -v xcrun &> /dev/null; then
            echo "Checking if xcrun can find Transporter..."
            XCRUN_TRANSPORTER=$(xcrun --find iTMSTransporter 2>/dev/null || echo "")
            if [ -n "$XCRUN_TRANSPORTER" ] && [ -f "$XCRUN_TRANSPORTER" ]; then
              if check_transporter "$XCRUN_TRANSPORTER"; then
                exit 0
              fi
            fi
          fi

          # Try various Xcode locations (comprehensive search)
          XCODE_PATHS=(
            "/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/Versions/A/Frameworks/AppStoreService.framework/Versions/A/Support/iTMSTransporter"
            "/Applications/Xcode.app/Contents/itms/bin/iTMSTransporter"
            "/Applications/Xcode.app/Contents/Developer/usr/bin/iTMSTransporter"
            "/Library/Developer/CommandLineTools/itms/bin/iTMSTransporter"
            "/Library/Developer/CommandLineTools/usr/bin/iTMSTransporter"
          )

          # Add paths relative to xcode-select path if available
          if [ -n "$XCODE_PATH" ]; then
            XCODE_PATHS+=(
              "$XCODE_PATH/../SharedFrameworks/ContentDeliveryServices.framework/Versions/A/Frameworks/AppStoreService.framework/Versions/A/Support/iTMSTransporter"
              "$XCODE_PATH/../itms/bin/iTMSTransporter"
              "$XCODE_PATH/../Developer/usr/bin/iTMSTransporter"
            )
          fi

          for path in "${XCODE_PATHS[@]}"; do
            if check_transporter "$path"; then
              exit 0
            fi
          done

          # Also search inside Xcode.app more thoroughly
          if [ -d "/Applications/Xcode.app" ]; then
            echo "Searching inside Xcode.app..."
            FOUND_IN_XCODE=$(find /Applications/Xcode.app -name "iTMSTransporter" -type f -perm +111 2>/dev/null | head -1)
            if [ -n "$FOUND_IN_XCODE" ] && check_transporter "$FOUND_IN_XCODE"; then
              exit 0
            fi
            
            # Debug: List ContentDeliveryServices framework if it exists
            if [ -d "/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework" ]; then
              echo "Found ContentDeliveryServices.framework, listing contents..."
              find "/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework" -name "*Transporter*" -o -name "*itms*" 2>/dev/null | head -10 || true
            fi
          fi

          # 3. Check common system locations
          if check_transporter "/usr/local/itms/bin/iTMSTransporter"; then
            exit 0
          fi

          # 4. Try find command (more thorough search)
          FOUND=$(find /Applications /Library/Developer /usr/local -name "iTMSTransporter" -type f -perm +111 2>/dev/null | head -1)
          if [ -n "$FOUND" ] && check_transporter "$FOUND"; then
            exit 0
          fi

          # If not found, try to install Transporter
          echo "‚ö†Ô∏è  iTMSTransporter not found, attempting to install..."
          
          # Try installing mas-cli first (Mac App Store CLI)
          if ! command -v mas &> /dev/null; then
            echo "üì• Installing mas-cli (Mac App Store CLI)..."
            if command -v brew &> /dev/null; then
              brew install mas || echo "‚ö†Ô∏è  Failed to install mas-cli via Homebrew"
            else
              echo "‚ö†Ô∏è  Homebrew not available, cannot install mas-cli"
            fi
          fi
          
          # Try to install Transporter via mas-cli (requires App Store authentication)
          if command -v mas &> /dev/null; then
            echo "üì• Attempting to install Transporter via mas-cli..."
            echo "   Note: This requires App Store authentication"
            echo "   Transporter App Store ID: 1450874784"
            # mas install 1450874784
            # Note: This will likely fail in CI/CD due to authentication, but we'll try
            if mas install 1450874784 2>&1; then
              echo "‚úÖ Transporter installed successfully via mas-cli"
              # Check again after installation
              if check_transporter "/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter"; then
                exit 0
              fi
            else
              echo "‚ö†Ô∏è  Failed to install Transporter via mas-cli (likely authentication issue)"
            fi
          fi
          
          # Final check: try to find it one more time after potential installation
          echo "üîç Final search after installation attempts..."
          FINAL_SEARCH=$(find /Applications /Library/Developer /usr/local -name "iTMSTransporter" -type f -perm +111 2>/dev/null | head -1)
          if [ -n "$FINAL_SEARCH" ] && check_transporter "$FINAL_SEARCH"; then
            exit 0
          fi
          
          # If still not found, fail the workflow
          echo ""
          echo "‚ùå ERROR: iTMSTransporter not found and could not be installed!"
          echo ""
          echo "Transporter is REQUIRED for App Store Connect uploads."
          echo "GitHub Actions macOS runners should have Xcode installed, which includes Transporter."
          echo ""
          echo "This workflow will FAIL because upload cannot proceed without Transporter."
          echo ""
          echo "Troubleshooting:"
          echo "1. Check if Xcode is properly installed on the runner"
          echo "2. Verify Xcode version includes Transporter"
          echo "3. Check GitHub Actions runner image documentation"
          echo "4. Contact GitHub Support if Transporter should be available"
          echo ""
          echo "Searched locations:"
          echo "  - /Applications/Transporter.app"
          echo "  - Xcode.app paths (multiple locations)"
          echo "  - /Library/Developer/CommandLineTools"
          echo "  - /usr/local/itms"
          echo "  - Common system directories"
          echo ""
          echo "Installation attempts:"
          echo "  - mas-cli (Mac App Store CLI) - may require authentication"
          echo ""
          exit 1  # Fail the workflow - no point continuing without Transporter

      - name: Set up environment
        run: |
          echo "ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "TRIPLET=${{ matrix.triplet }}" >> $GITHUB_ENV
          # Check which installation location vcpkg uses (manifest mode uses vcpkg_installed)
          if [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            echo "VCPKG_INSTALLED=./vcpkg_installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          else
            echo "VCPKG_INSTALLED=./vcpkg/installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          fi
          echo "APP_VERSION=${{ steps.version.outputs.version }}" >> $GITHUB_ENV

      - name: Clone vcpkg
        run: |
          git clone https://github.com/Microsoft/vcpkg.git vcpkg

      - name: Make scripts executable
        run: |
          chmod +x scripts/*.sh
          chmod +x sign_package.sh
          if [ -f "vcpkg/bootstrap-vcpkg.sh" ]; then
            chmod +x vcpkg/bootstrap-vcpkg.sh
          fi

      - name: Bootstrap vcpkg
        run: |
          cd vcpkg
          ./bootstrap-vcpkg.sh

      - name: Install build dependencies
        run: |
          # Install nasm required for ffmpeg build
          brew install nasm

      - name: Install dependencies
        run: |
          echo "Installing vcpkg packages for triplet: ${{ matrix.triplet }}"
          echo "Checking vcpkg installation directory before install:"
          if [ -d "./vcpkg/installed" ]; then
            ls -la "./vcpkg/installed/" || true
            if [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
              echo "Triplet directory exists, checking contents:"
              ls -la "./vcpkg/installed/${{ matrix.triplet }}/" || true
            fi
          else
            echo "installed directory does not exist yet"
          fi

          # Ensure installed directory exists
          mkdir -p "./vcpkg/installed/${{ matrix.triplet }}"

          # Always run vcpkg install - it will skip already installed packages
          # but will install missing ones even if cache was restored
          echo "Running vcpkg install..."
          # Use manifest mode by running from project root (vcpkg.json is in root)
          if ! ./vcpkg/vcpkg install --triplet ${{ matrix.triplet }}; then
            echo "‚ùå Error: vcpkg install failed!"
            echo "Checking vcpkg installed directory:"
            ls -la "./vcpkg/installed/" || echo "installed directory does not exist"
            echo "Checking for alternative installation locations:"
            find . -type d -name "installed" 2>/dev/null | head -10 || true
            echo "Checking vcpkg packages directory:"
            ls -la "./vcpkg/packages/" 2>/dev/null | head -20 || true
            exit 1
          fi

          echo "‚úÖ vcpkg install completed successfully"
          echo "Checking installed directory after install:"
          echo "Current directory: $(pwd)"
          echo "Looking for installed directory:"
          ls -la "./vcpkg/" || true

          # Wait a moment for any background operations to complete
          sleep 2

          if [ -d "./vcpkg/installed" ]; then
            echo "Found installed directory, listing contents:"
            ls -la "./vcpkg/installed/" || true
          fi

          # Check if packages directory has the triplet (packages are built here first)
          if [ -d "./vcpkg/packages" ]; then
            echo "Checking packages directory:"
            ls -la "./vcpkg/packages/" | grep "${{ matrix.triplet }}" || true
          fi

          # Check both possible installation locations (vcpkg/installed and vcpkg_installed)
          INSTALLED_DIR=""
          if [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
            echo "‚úÖ Found triplet directory in vcpkg_installed (manifest mode)"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
            echo "‚úÖ Found triplet directory in vcpkg/installed"
          else
            echo "‚ö†Ô∏è  Triplet directory not found in either location, checking packages:"
            if [ -d "./vcpkg/packages" ]; then
              echo "Packages directory exists, checking for installed packages:"
              find "./vcpkg/packages" -maxdepth 1 -type d -name "*_${{ matrix.triplet }}" | head -5 || true
            fi
            echo "Checking for vcpkg_installed directory:"
            ls -la "./vcpkg_installed/" 2>/dev/null || echo "vcpkg_installed does not exist"
            echo "Checking for vcpkg/installed directory:"
            ls -la "./vcpkg/installed/" 2>/dev/null || echo "vcpkg/installed does not exist"
            echo "‚ùå ERROR: Triplet directory not found in either location!"
            echo "Searching for triplet directory in alternative locations:"
            find . -type d -name "${{ matrix.triplet }}" 2>/dev/null | head -10 || true
            echo "Checking vcpkg root structure:"
            find ./vcpkg -maxdepth 3 -type d | head -20 || true
            exit 1
          fi

          # Display contents of found directory
          if [ -n "$INSTALLED_DIR" ]; then
            echo "Installed directory: $INSTALLED_DIR"
            ls -la "$INSTALLED_DIR/" || true
            echo "Package count:"
            find "$INSTALLED_DIR" -name "*.pc" -o -name "*.cmake" | wc -l || true
            # Update environment variable if using vcpkg_installed
            if [[ "$INSTALLED_DIR" == "./vcpkg_installed"* ]]; then
              echo "VCPKG_INSTALLED=$INSTALLED_DIR" >> $GITHUB_ENV
            fi
          fi

      - name: Verify vcpkg installation
        run: |
          echo "Verifying vcpkg installation for ${{ matrix.triplet }}..."

          # Determine installed directory (use environment variable if set, otherwise check both locations)
          if [ -n "$VCPKG_INSTALLED" ]; then
            INSTALLED_DIR="$VCPKG_INSTALLED"
          elif [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
          else
            echo "‚ùå Error: vcpkg installed directory for triplet ${{ matrix.triplet }} not found!"
            echo "Checking both possible locations:"
            ls -la "./vcpkg/installed/" 2>/dev/null || echo "vcpkg/installed does not exist"
            ls -la "./vcpkg_installed/" 2>/dev/null || echo "vcpkg_installed does not exist"
            exit 1
          fi

          echo "‚úÖ Installed directory exists: $INSTALLED_DIR"

          # Check for SDL2 headers
          if [ ! -f "$INSTALLED_DIR/include/SDL2/SDL.h" ]; then
            echo "‚ùå Error: SDL2 headers not found!"
            echo "Checking include directory contents:"
            ls -la "$INSTALLED_DIR/include/" || true
            if [ -d "$INSTALLED_DIR/include" ]; then
              echo "Subdirectories in include:"
              find "$INSTALLED_DIR/include" -maxdepth 2 -type d | head -20
            fi
            exit 1
          fi

          echo "‚úÖ SDL2 headers found at: $INSTALLED_DIR/include/SDL2/SDL.h"
          echo "VCPKG_INSTALLED=$INSTALLED_DIR" >> $GITHUB_ENV

      - name: Update Makefile for architecture
        run: |
          # Determine installed directory (use environment variable if set, otherwise check both locations)
          if [ -n "$VCPKG_INSTALLED" ]; then
            INSTALLED_DIR="$VCPKG_INSTALLED"
          elif [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
          else
            echo "‚ùå Error: Could not determine vcpkg installed directory!"
            exit 1
          fi

          # Update VCPKG_INSTALLED path in Makefile (macOS sed syntax)
          sed -i '' "s|VCPKG_INSTALLED := .*|VCPKG_INSTALLED := $INSTALLED_DIR|" Makefile
          # Update RPATH (escape slashes for sed)
          INSTALLED_DIR_ESCAPED=$(echo "$INSTALLED_DIR" | sed 's|/|\\/|g')
          sed -i '' "s|-Wl,-rpath,\\./vcpkg/installed/[^ ]*|-Wl,-rpath,$INSTALLED_DIR/lib|" Makefile
          sed -i '' "s|-Wl,-rpath,\\./vcpkg_installed/[^ ]*|-Wl,-rpath,$INSTALLED_DIR/lib|" Makefile
          echo "Updated Makefile for ${{ matrix.triplet }}"
          echo "VCPKG_INSTALLED path: $INSTALLED_DIR"
          echo "VCPKG_INSTALLED in Makefile:"
          grep "VCPKG_INSTALLED" Makefile
          echo "Include path:"
          grep "INCLUDES" Makefile

      - name: Build application
        env:
          ARCH: ${{ matrix.arch }}
        run: |
          # Clean build for production releases (ensures reproducible builds)
          make clean
          make

      - name: Create app bundle
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          make app

      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Check if secrets are configured
          if [ -z "$MACOS_CERTIFICATE" ] || [ -z "$MACOS_CERTIFICATE_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Signing secrets not configured, skipping code signing"
            exit 0
          fi

          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Allow codesign to access the certificate
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" $KEYCHAIN_PATH

          # Find and export the signing identity (App Store certificate)
          echo "üîç Searching for App Store certificates..."
          echo "Available certificates in keychain:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH || true
          echo ""

          # Try multiple patterns to find App Store certificate
          # Priority: Apple Distribution > 3rd Party Mac Developer Application > Mac App Distribution
          IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null | \
            grep -i "Apple Distribution" | \
            head -1 | \
            sed -n 's/.*"\(.*\)".*/\1/p')

          if [ -z "$IDENTITY" ]; then
            IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null | \
              grep -i "3rd Party Mac Developer Application" | \
              head -1 | \
              sed -n 's/.*"\(.*\)".*/\1/p')
          fi

          if [ -z "$IDENTITY" ]; then
            IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null | \
              grep -i "Mac App Distribution" | \
              head -1 | \
              sed -n 's/.*"\(.*\)".*/\1/p')
          fi

          # If still not found, try to find any certificate that's NOT Developer ID
          if [ -z "$IDENTITY" ]; then
            echo "‚ö†Ô∏è  App Store certificate not found with standard patterns, trying alternative search..."
            ALL_CERTS=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null)
            IDENTITY=$(echo "$ALL_CERTS" | \
              grep -v "Developer ID" | \
              grep -v "Apple Development" | \
              head -1 | \
              sed -n 's/.*"\(.*\)".*/\1/p')
          fi

          if [ -z "$IDENTITY" ]; then
            echo "‚ùå Error: Could not find App Store certificate"
            echo "   Expected: Apple Distribution or 3rd Party Mac Developer Application"
            echo "   Check that MACOS_CERTIFICATE contains the correct App Store certificate"
            echo ""
            echo "All available certificates:"
            security find-identity -v -p codesigning $KEYCHAIN_PATH || true
            security list-keychain -d user -s login.keychain
            exit 1
          fi

          echo "‚úÖ Found signing identity: $IDENTITY"
          echo "MACOS_SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "$KEYCHAIN_PATH" > $RUNNER_TEMP/keychain_path.txt
          echo "SIGNING_ENABLED=true" >> $GITHUB_ENV

      - name: Sign app bundle
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_SIGNING_IDENTITY: ${{ env.MACOS_SIGNING_IDENTITY }}
        run: |
          # Ensure keychain is accessible for signing
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi
          ./scripts/sign_app.sh

      # Notarization is DISABLED for App Store builds
      # The App Store handles signing and notarization during review
      # Notarization is only needed for apps distributed outside the App Store (DMG downloads)
      #
      # - name: Check notarization credentials
      #   if: env.SIGNING_ENABLED == 'true' && github.ref_type == 'tag'
      #   id: check_notary
      #   run: |
      #     if [ -n "${{ secrets.NOTARY_APPLE_ID }}" ] && [ -n "${{ secrets.NOTARY_TEAM_ID }}" ] && [ -n "${{ secrets.NOTARY_PASSWORD }}" ]; then
      #       echo "notarization_enabled=true" >> $GITHUB_OUTPUT
      #     else
      #       echo "notarization_enabled=false" >> $GITHUB_OUTPUT
      #       echo "‚ö†Ô∏è  Notarization credentials not configured - skipping notarization"
      #     fi
      #
      # - name: Notarize app bundle
      #   if: env.SIGNING_ENABLED == 'true' && github.ref_type == 'tag' && steps.check_notary.outputs.notarization_enabled == 'true'
      #   env:
      #     NOTARY_APPLE_ID: ${{ secrets.NOTARY_APPLE_ID }}
      #     NOTARY_TEAM_ID: ${{ secrets.NOTARY_TEAM_ID }}
      #     NOTARY_PASSWORD: ${{ secrets.NOTARY_PASSWORD }}
      #   timeout-minutes: 20
      #   run: |
      #     echo "üöÄ Starting notarization (production release)..."
      #     echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      #     echo "‚è±Ô∏è  Notarization typically takes 5-15 minutes"
      #     echo "   This is Apple's server-side security scan - cannot be sped up"
      #     echo "   The workflow will wait automatically..."
      #     echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      #     ./scripts/notarize_app.sh
      #     echo "‚úÖ Notarization complete"

      # Import Mac Installer Distribution certificate for .pkg signing
      # This must be done before calling upload_to_appstore.sh
      - name: Import Mac Installer Distribution certificate
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        env:
          MACOS_INSTALLER_CERTIFICATE: ${{ secrets.MACOS_INSTALLER_CERTIFICATE }}
          MACOS_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_INSTALLER_CERTIFICATE_PASSWORD }}
        run: |
          # Check if installer certificate secrets are configured
          if [ -z "$MACOS_INSTALLER_CERTIFICATE" ] || [ -z "$MACOS_INSTALLER_CERTIFICATE_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Installer certificate secrets not configured"
            echo "   .pkg will be created but not signed"
            echo "installer_cert_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Import the Mac Installer Distribution certificate to the existing keychain
          CERTIFICATE_PATH=$RUNNER_TEMP/installer_certificate.p12
          KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)

          echo "Importing Mac Installer Distribution certificate..."
          echo "$MACOS_INSTALLER_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH
          security import $CERTIFICATE_PATH -P "$MACOS_INSTALLER_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          rm $CERTIFICATE_PATH

          # Verify the certificate is available
          # Use macappstore policy to find installer certificates
          security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
          if security find-identity -v -p macappstore | grep -q "3rd Party Mac Developer Installer"; then
            echo "‚úÖ Mac Installer Distribution certificate imported successfully"
            echo "installer_cert_available=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  Warning: Certificate imported but not found with macappstore policy"
            echo "   It may still work - upload_to_appstore.sh will try to use it"
            echo "installer_cert_available=true" >> $GITHUB_OUTPUT
          fi
        id: import_installer_cert

      # Create .itmsp package for App Store (production releases)
      # This creates the signed .pkg and .itmsp package
      # Upload will be attempted separately if iTMSTransporter is available
      - name: Create .itmsp package for App Store (production releases)
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Ensure keychain is accessible for .pkg signing
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi

          echo "üì¶ Creating .itmsp package for App Store Connect..."
          echo "   This includes creating and signing the .pkg installer"

          # Create .itmsp package (create_itmsp.sh will sign .pkg if installer certificate is available)
          ./scripts/create_itmsp.sh

          echo "‚úÖ .itmsp package created: export/Blackhole Sim.itmsp"

      # Upload to App Store Connect
      # The upload script will find Transporter automatically using comprehensive search
      - name: Upload to App Store Connect (production releases)
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        env:
          TRANSPORTER_APPLE_ID: ${{ secrets.TRANSPORTER_APPLE_ID }}
          TRANSPORTER_PASSWORD: ${{ secrets.TRANSPORTER_PASSWORD }}
          APP_VERSION: ${{ steps.version.outputs.version }}
        timeout-minutes: 30
        continue-on-error: true
        run: |
          # Ensure keychain is accessible
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi

          # Check if Transporter credentials are configured
          if [ -z "$TRANSPORTER_APPLE_ID" ] || [ -z "$TRANSPORTER_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Transporter credentials not configured, skipping App Store Connect upload"
            echo "   The .itmsp package will be available as an artifact for manual upload"
            echo ""
            echo "To enable automatic upload, add these secrets:"
            echo "  - TRANSPORTER_APPLE_ID: Your Apple ID email"
            echo "  - TRANSPORTER_PASSWORD: An app-specific password (create at appleid.apple.com)"
            exit 0
          fi

          # Upload using upload_to_appstore.sh
          # The script will automatically find Transporter using comprehensive search
          # It will also find the existing .itmsp package and upload it
          echo "üì§ Uploading to App Store Connect..."
          echo "   The upload script will find Transporter automatically"
          echo ""

          ./scripts/upload_to_appstore.sh || {
            EXIT_CODE=$?
            echo ""
            echo "‚ö†Ô∏è  Upload failed (exit code: $EXIT_CODE)"
            echo "   The .itmsp package is available as an artifact for manual upload"
            echo ""
            echo "Possible reasons:"
            echo "  - Transporter not found (check 'Check for Transporter (early validation)' step logs)"
            echo "  - Network issues"
            echo "  - Invalid credentials"
            echo "  - App Store Connect API issues"
            echo ""
            echo "To upload manually:"
            echo "  1. Download the .itmsp artifact from this workflow run"
            echo "  2. Install Transporter from: https://apps.apple.com/app/transporter/id1450874784"
            echo "  3. Run: open -a Transporter /path/to/Blackhole Sim.itmsp"
            exit 0  # Don't fail the workflow
          }

          echo ""
          echo "‚úÖ Upload completed successfully!"
          echo "   Check App Store Connect for processing status"

      # DMG creation is optional - only needed for testing or direct distribution
      # App Store distribution doesn't require DMG files
      - name: Create DMG (optional - for testing)
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          ./scripts/create_dmg.sh
        continue-on-error: true

      # DMG artifacts are optional - mainly for testing/backup
      # App Store distribution doesn't use DMG files
      - name: Rename DMG with architecture
        run: |
          cd export
          VERSION="${{ steps.version.outputs.version }}"
          if [ -f "Blackhole Sim-${VERSION}.dmg" ]; then
            mv "Blackhole Sim-${VERSION}.dmg" "Blackhole Sim-${VERSION}-${{ matrix.arch }}.dmg"
          fi
        continue-on-error: true

      - name: Upload DMG artifact (optional - for testing)
        uses: actions/upload-artifact@v4
        with:
          name: BlackholeSim-${{ steps.version.outputs.version }}-${{ matrix.arch }}-dmg
          path: export/Blackhole Sim-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg
          retention-days: 7
          if-no-files-found: warn
        continue-on-error: true

      - name: Upload .itmsp package artifact (App Store)
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        uses: actions/upload-artifact@v4
        with:
          name: BlackholeSim-${{ steps.version.outputs.version }}-appstore-itmsp
          path: export/Blackhole Sim.itmsp
          retention-days: 30
          if-no-files-found: warn
        continue-on-error: true

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security delete-keychain "$KEYCHAIN_PATH" || true
            security list-keychain -d user -s login.keychain || true
          fi

      - name: Summary
        run: |
          echo "## Build Summary for ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Architecture: ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Triplet: ${{ matrix.triplet }}" >> $GITHUB_STEP_SUMMARY
          echo "- Runner: ${{ matrix.runner }}" >> $GITHUB_STEP_SUMMARY
          if [ "${SIGNING_ENABLED:-false}" = "true" ]; then
            echo "- ‚úÖ Code signed: Yes" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ö†Ô∏è Code signed: No (secrets not configured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Version: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.ref_type }}" = "tag" ] && [ "${SIGNING_ENABLED:-false}" = "true" ] && [ "${{ matrix.arch }}" = "arm64" ]; then
            echo "- üì¶ App Store: Blackhole Sim.itmsp (automatically uploaded)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -f "export/Blackhole Sim-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg" ]; then
            echo "- üíæ DMG: Created (available as artifact for testing)" >> $GITHUB_STEP_SUMMARY
          fi

  # GitHub Releases DISABLED - App Store distribution only
  # DMG files are not needed since the app is distributed via the App Store
  # The App Store handles versioning and distribution automatically
  #
  # upload-release:
  #   needs: build
  #   if: github.ref_type == 'tag' && startsWith(github.ref_name, 'prod-v')
  #   runs-on: macos-latest
  #   permissions:
  #     contents: write # Required to create/update releases and upload release assets
  #
  #   steps:
  #     - name: Extract version from tag
  #       id: version
  #       run: |
  #         if [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
  #           VERSION="${BASH_REMATCH[1]}"
  #           echo "version=$VERSION" >> $GITHUB_OUTPUT
  #           echo "‚úÖ Extracted version from tag: $VERSION"
  #         else
  #           echo "‚ùå Error: Tag format invalid"
  #           exit 1
  #         fi
  #
  #     - name: Download all artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         pattern: BlackholeSim-${{ steps.version.outputs.version }}-*-dmg
  #         merge-multiple: false
  #         path: release-assets
  #
  #     - name: Find and prepare DMG files
  #       run: |
  #         echo "Looking for DMG files in release-assets..."
  #         find release-assets -name "*.dmg" -type f
  #         # Count DMG files found
  #         DMG_COUNT=$(find release-assets -name "*.dmg" -type f | wc -l | tr -d ' ')
  #         echo "Found $DMG_COUNT DMG file(s)"
  #         if [ "$DMG_COUNT" -eq 0 ]; then
  #           echo "‚ùå Error: No DMG files found!"
  #           exit 1
  #         fi
  #
  #     - name: Upload release assets
  #       uses: softprops/action-gh-release@v1
  #       with:
  #         files: release-assets/**/*.dmg
  #         tag_name: ${{ github.ref_name }}
  #         name: Release ${{ steps.version.outputs.version }}
  #         draft: false
  #         prerelease: false
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
