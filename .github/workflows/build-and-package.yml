name: Build and Package

# This workflow builds the Blackhole Sim application for both Intel (x86_64) and Apple Silicon (arm64)
# architectures and uploads to the App Store Connect.
#
# Triggers:
#   - Tags matching 'prod-v*' pattern (e.g., prod-v1.0.0) - builds and uploads to App Store
#   - Manual workflow dispatch (can specify version via input)
#
# Version Handling:
#   - Tag format: prod-v<VERSION> (e.g., prod-v1.0.0 extracts version "1.0.0")
#   - Version is used in app bundle Info.plist and App Store metadata
#   - Default version for manual builds: 1.0
#
# Outputs:
#   - .itmsp package automatically uploaded to App Store Connect
#   - DMG files created as workflow artifacts (for testing/backup only)
#
# Note: Code signing is enabled if MACOS_CERTIFICATE and MACOS_CERTIFICATE_PASSWORD secrets are configured.
# To set up signing:
#   1. Export your App Store certificate (Apple Distribution or 3rd Party Mac Developer Application) as a .p12 file
#   2. Base64 encode it: base64 -i YourCertificate.p12 | pbcopy
#   3. Add it as a GitHub secret: MACOS_CERTIFICATE
#   4. Add the certificate password as another secret: MACOS_CERTIFICATE_PASSWORD
#
# Notarization is DISABLED for App Store builds (the App Store handles this during review).
# Notarization is only needed for apps distributed outside the App Store (DMG downloads).
#
# App Store Connect upload is enabled if MACOS_INSTALLER_CERTIFICATE, MACOS_INSTALLER_CERTIFICATE_PASSWORD,
# TRANSPORTER_APPLE_ID, and TRANSPORTER_PASSWORD secrets are configured.
# To set up App Store upload:
#   1. Export your Mac Installer Distribution certificate as a .p12 file
#   2. Base64 encode it: base64 -i MacInstallerDistribution.p12 | pbcopy
#   3. Add it as a GitHub secret: MACOS_INSTALLER_CERTIFICATE
#   4. Add the certificate password as another secret: MACOS_INSTALLER_CERTIFICATE_PASSWORD
#   5. Create an app-specific password at appleid.apple.com
#   6. Add your Apple ID as secret: TRANSPORTER_APPLE_ID
#   7. Add the app-specific password as secret: TRANSPORTER_PASSWORD

on:
  push:
    # branches:
    #   - main
    tags:
      - "prod-v*" # Trigger on production tags like prod-v1.0.0
  workflow_dispatch: # Allow manual triggering
    inputs:
      version:
        description: "Version number (e.g., 1.0.0)"
        required: false
        type: string

jobs:
  build:
    strategy:
      matrix:
        # x86_64 builds are commented out to save time and cost
        # Uncomment the line below and the x86_64 include entry to enable Intel builds
        arch: [arm64] # , x86_64]
        include:
          - arch: arm64
            runner: macos-14
            triplet: arm64-osx
          # - arch: x86_64
          #   runner: macos-13
          #   triplet: x64-osx

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for tags

      - name: Extract version from tag
        id: version
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]] && [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
            # Extract version from tag (everything after prod-v)
            VERSION="${BASH_REMATCH[1]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Extracted version from tag: $VERSION"
          elif [[ -n "${{ inputs.version }}" ]]; then
            # Use version from workflow_dispatch input
            VERSION="${{ inputs.version }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Using version from input: $VERSION"
          else
            # Default version for branch builds
            VERSION="1.0"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Using default version: $VERSION"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set up environment
        run: |
          echo "ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "TRIPLET=${{ matrix.triplet }}" >> $GITHUB_ENV
          # Check which installation location vcpkg uses (manifest mode uses vcpkg_installed)
          if [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            echo "VCPKG_INSTALLED=./vcpkg_installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          else
            echo "VCPKG_INSTALLED=./vcpkg/installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          fi
          echo "APP_VERSION=${{ steps.version.outputs.version }}" >> $GITHUB_ENV

      - name: Clone vcpkg
        run: |
          git clone https://github.com/Microsoft/vcpkg.git vcpkg

      - name: Make scripts executable
        run: |
          chmod +x scripts/*.sh
          chmod +x sign_package.sh
          if [ -f "vcpkg/bootstrap-vcpkg.sh" ]; then
            chmod +x vcpkg/bootstrap-vcpkg.sh
          fi

      - name: Bootstrap vcpkg
        run: |
          cd vcpkg
          ./bootstrap-vcpkg.sh

      - name: Install build dependencies
        run: |
          # Install nasm required for ffmpeg build
          brew install nasm

      - name: Install dependencies
        run: |
          echo "Installing vcpkg packages for triplet: ${{ matrix.triplet }}"
          echo "Checking vcpkg installation directory before install:"
          if [ -d "./vcpkg/installed" ]; then
            ls -la "./vcpkg/installed/" || true
            if [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
              echo "Triplet directory exists, checking contents:"
              ls -la "./vcpkg/installed/${{ matrix.triplet }}/" || true
            fi
          else
            echo "installed directory does not exist yet"
          fi

          # Ensure installed directory exists
          mkdir -p "./vcpkg/installed/${{ matrix.triplet }}"

          # Always run vcpkg install - it will skip already installed packages
          # but will install missing ones even if cache was restored
          echo "Running vcpkg install..."
          # Use manifest mode by running from project root (vcpkg.json is in root)
          if ! ./vcpkg/vcpkg install --triplet ${{ matrix.triplet }}; then
            echo "‚ùå Error: vcpkg install failed!"
            echo "Checking vcpkg installed directory:"
            ls -la "./vcpkg/installed/" || echo "installed directory does not exist"
            echo "Checking for alternative installation locations:"
            find . -type d -name "installed" 2>/dev/null | head -10 || true
            echo "Checking vcpkg packages directory:"
            ls -la "./vcpkg/packages/" 2>/dev/null | head -20 || true
            exit 1
          fi

          echo "‚úÖ vcpkg install completed successfully"
          echo "Checking installed directory after install:"
          echo "Current directory: $(pwd)"
          echo "Looking for installed directory:"
          ls -la "./vcpkg/" || true

          # Wait a moment for any background operations to complete
          sleep 2

          if [ -d "./vcpkg/installed" ]; then
            echo "Found installed directory, listing contents:"
            ls -la "./vcpkg/installed/" || true
          fi

          # Check if packages directory has the triplet (packages are built here first)
          if [ -d "./vcpkg/packages" ]; then
            echo "Checking packages directory:"
            ls -la "./vcpkg/packages/" | grep "${{ matrix.triplet }}" || true
          fi

          # Check both possible installation locations (vcpkg/installed and vcpkg_installed)
          INSTALLED_DIR=""
          if [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
            echo "‚úÖ Found triplet directory in vcpkg_installed (manifest mode)"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
            echo "‚úÖ Found triplet directory in vcpkg/installed"
          else
            echo "‚ö†Ô∏è  Triplet directory not found in either location, checking packages:"
            if [ -d "./vcpkg/packages" ]; then
              echo "Packages directory exists, checking for installed packages:"
              find "./vcpkg/packages" -maxdepth 1 -type d -name "*_${{ matrix.triplet }}" | head -5 || true
            fi
            echo "Checking for vcpkg_installed directory:"
            ls -la "./vcpkg_installed/" 2>/dev/null || echo "vcpkg_installed does not exist"
            echo "Checking for vcpkg/installed directory:"
            ls -la "./vcpkg/installed/" 2>/dev/null || echo "vcpkg/installed does not exist"
            echo "‚ùå ERROR: Triplet directory not found in either location!"
            echo "Searching for triplet directory in alternative locations:"
            find . -type d -name "${{ matrix.triplet }}" 2>/dev/null | head -10 || true
            echo "Checking vcpkg root structure:"
            find ./vcpkg -maxdepth 3 -type d | head -20 || true
            exit 1
          fi

          # Display contents of found directory
          if [ -n "$INSTALLED_DIR" ]; then
            echo "Installed directory: $INSTALLED_DIR"
            ls -la "$INSTALLED_DIR/" || true
            echo "Package count:"
            find "$INSTALLED_DIR" -name "*.pc" -o -name "*.cmake" | wc -l || true
            # Update environment variable if using vcpkg_installed
            if [[ "$INSTALLED_DIR" == "./vcpkg_installed"* ]]; then
              echo "VCPKG_INSTALLED=$INSTALLED_DIR" >> $GITHUB_ENV
            fi
          fi

      - name: Verify vcpkg installation
        run: |
          echo "Verifying vcpkg installation for ${{ matrix.triplet }}..."

          # Determine installed directory (use environment variable if set, otherwise check both locations)
          if [ -n "$VCPKG_INSTALLED" ]; then
            INSTALLED_DIR="$VCPKG_INSTALLED"
          elif [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
          else
            echo "‚ùå Error: vcpkg installed directory for triplet ${{ matrix.triplet }} not found!"
            echo "Checking both possible locations:"
            ls -la "./vcpkg/installed/" 2>/dev/null || echo "vcpkg/installed does not exist"
            ls -la "./vcpkg_installed/" 2>/dev/null || echo "vcpkg_installed does not exist"
            exit 1
          fi

          echo "‚úÖ Installed directory exists: $INSTALLED_DIR"

          # Check for SDL2 headers
          if [ ! -f "$INSTALLED_DIR/include/SDL2/SDL.h" ]; then
            echo "‚ùå Error: SDL2 headers not found!"
            echo "Checking include directory contents:"
            ls -la "$INSTALLED_DIR/include/" || true
            if [ -d "$INSTALLED_DIR/include" ]; then
              echo "Subdirectories in include:"
              find "$INSTALLED_DIR/include" -maxdepth 2 -type d | head -20
            fi
            exit 1
          fi

          echo "‚úÖ SDL2 headers found at: $INSTALLED_DIR/include/SDL2/SDL.h"
          echo "VCPKG_INSTALLED=$INSTALLED_DIR" >> $GITHUB_ENV

      - name: Update Makefile for architecture
        run: |
          # Determine installed directory (use environment variable if set, otherwise check both locations)
          if [ -n "$VCPKG_INSTALLED" ]; then
            INSTALLED_DIR="$VCPKG_INSTALLED"
          elif [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
          else
            echo "‚ùå Error: Could not determine vcpkg installed directory!"
            exit 1
          fi

          # Update VCPKG_INSTALLED path in Makefile (macOS sed syntax)
          sed -i '' "s|VCPKG_INSTALLED := .*|VCPKG_INSTALLED := $INSTALLED_DIR|" Makefile
          # Update RPATH (escape slashes for sed)
          INSTALLED_DIR_ESCAPED=$(echo "$INSTALLED_DIR" | sed 's|/|\\/|g')
          sed -i '' "s|-Wl,-rpath,\\./vcpkg/installed/[^ ]*|-Wl,-rpath,$INSTALLED_DIR/lib|" Makefile
          sed -i '' "s|-Wl,-rpath,\\./vcpkg_installed/[^ ]*|-Wl,-rpath,$INSTALLED_DIR/lib|" Makefile
          echo "Updated Makefile for ${{ matrix.triplet }}"
          echo "VCPKG_INSTALLED path: $INSTALLED_DIR"
          echo "VCPKG_INSTALLED in Makefile:"
          grep "VCPKG_INSTALLED" Makefile
          echo "Include path:"
          grep "INCLUDES" Makefile

      - name: Build application
        env:
          ARCH: ${{ matrix.arch }}
        run: |
          # Clean build for production releases (ensures reproducible builds)
          make clean
          make

      - name: Create app bundle
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          make app

      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Check if secrets are configured
          if [ -z "$MACOS_CERTIFICATE" ] || [ -z "$MACOS_CERTIFICATE_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Signing secrets not configured, skipping code signing"
            exit 0
          fi

          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Allow codesign to access the certificate
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" $KEYCHAIN_PATH

          # Find and export the signing identity (App Store certificate)
          echo "üîç Searching for App Store certificates..."
          echo "Available certificates in keychain:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH || true
          echo ""

          # Try multiple patterns to find App Store certificate
          # Priority: Apple Distribution > 3rd Party Mac Developer Application > Mac App Distribution
          IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null | \
            grep -i "Apple Distribution" | \
            head -1 | \
            sed -n 's/.*"\(.*\)".*/\1/p')

          if [ -z "$IDENTITY" ]; then
            IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null | \
              grep -i "3rd Party Mac Developer Application" | \
              head -1 | \
              sed -n 's/.*"\(.*\)".*/\1/p')
          fi

          if [ -z "$IDENTITY" ]; then
            IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null | \
              grep -i "Mac App Distribution" | \
              head -1 | \
              sed -n 's/.*"\(.*\)".*/\1/p')
          fi

          # If still not found, try to find any certificate that's NOT Developer ID
          if [ -z "$IDENTITY" ]; then
            echo "‚ö†Ô∏è  App Store certificate not found with standard patterns, trying alternative search..."
            ALL_CERTS=$(security find-identity -v -p codesigning $KEYCHAIN_PATH 2>/dev/null)
            IDENTITY=$(echo "$ALL_CERTS" | \
              grep -v "Developer ID" | \
              grep -v "Apple Development" | \
              head -1 | \
              sed -n 's/.*"\(.*\)".*/\1/p')
          fi

          if [ -z "$IDENTITY" ]; then
            echo "‚ùå Error: Could not find App Store certificate"
            echo "   Expected: Apple Distribution or 3rd Party Mac Developer Application"
            echo "   Check that MACOS_CERTIFICATE contains the correct App Store certificate"
            echo ""
            echo "All available certificates:"
            security find-identity -v -p codesigning $KEYCHAIN_PATH || true
            security list-keychain -d user -s login.keychain
            exit 1
          fi

          echo "‚úÖ Found signing identity: $IDENTITY"
          echo "MACOS_SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "$KEYCHAIN_PATH" > $RUNNER_TEMP/keychain_path.txt
          echo "SIGNING_ENABLED=true" >> $GITHUB_ENV

      - name: Sign app bundle
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_SIGNING_IDENTITY: ${{ env.MACOS_SIGNING_IDENTITY }}
        run: |
          # Ensure keychain is accessible for signing
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi
          ./scripts/sign_app.sh

      # Notarization is DISABLED for App Store builds
      # The App Store handles signing and notarization during review
      # Notarization is only needed for apps distributed outside the App Store (DMG downloads)
      #
      # - name: Check notarization credentials
      #   if: env.SIGNING_ENABLED == 'true' && github.ref_type == 'tag'
      #   id: check_notary
      #   run: |
      #     if [ -n "${{ secrets.NOTARY_APPLE_ID }}" ] && [ -n "${{ secrets.NOTARY_TEAM_ID }}" ] && [ -n "${{ secrets.NOTARY_PASSWORD }}" ]; then
      #       echo "notarization_enabled=true" >> $GITHUB_OUTPUT
      #     else
      #       echo "notarization_enabled=false" >> $GITHUB_OUTPUT
      #       echo "‚ö†Ô∏è  Notarization credentials not configured - skipping notarization"
      #     fi
      #
      # - name: Notarize app bundle
      #   if: env.SIGNING_ENABLED == 'true' && github.ref_type == 'tag' && steps.check_notary.outputs.notarization_enabled == 'true'
      #   env:
      #     NOTARY_APPLE_ID: ${{ secrets.NOTARY_APPLE_ID }}
      #     NOTARY_TEAM_ID: ${{ secrets.NOTARY_TEAM_ID }}
      #     NOTARY_PASSWORD: ${{ secrets.NOTARY_PASSWORD }}
      #   timeout-minutes: 20
      #   run: |
      #     echo "üöÄ Starting notarization (production release)..."
      #     echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      #     echo "‚è±Ô∏è  Notarization typically takes 5-15 minutes"
      #     echo "   This is Apple's server-side security scan - cannot be sped up"
      #     echo "   The workflow will wait automatically..."
      #     echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      #     ./scripts/notarize_app.sh
      #     echo "‚úÖ Notarization complete"

      # Import Mac Installer Distribution certificate for .pkg signing
      # This must be done before calling upload_to_appstore.sh
      - name: Import Mac Installer Distribution certificate
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        env:
          MACOS_INSTALLER_CERTIFICATE: ${{ secrets.MACOS_INSTALLER_CERTIFICATE }}
          MACOS_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_INSTALLER_CERTIFICATE_PASSWORD }}
        run: |
          # Check if installer certificate secrets are configured
          if [ -z "$MACOS_INSTALLER_CERTIFICATE" ] || [ -z "$MACOS_INSTALLER_CERTIFICATE_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Installer certificate secrets not configured"
            echo "   .pkg will be created but not signed"
            echo "installer_cert_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Import the Mac Installer Distribution certificate to the existing keychain
          CERTIFICATE_PATH=$RUNNER_TEMP/installer_certificate.p12
          KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)

          echo "Importing Mac Installer Distribution certificate..."
          echo "$MACOS_INSTALLER_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH
          security import $CERTIFICATE_PATH -P "$MACOS_INSTALLER_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          rm $CERTIFICATE_PATH

          # Verify the certificate is available
          # Use macappstore policy to find installer certificates
          security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
          if security find-identity -v -p macappstore | grep -q "3rd Party Mac Developer Installer"; then
            echo "‚úÖ Mac Installer Distribution certificate imported successfully"
            echo "installer_cert_available=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  Warning: Certificate imported but not found with macappstore policy"
            echo "   It may still work - upload_to_appstore.sh will try to use it"
            echo "installer_cert_available=true" >> $GITHUB_OUTPUT
          fi
        id: import_installer_cert

      # Install Transporter for App Store uploads
      # Note: Transporter is required for iTMSTransporter CLI tool
      # Transporter is not available via Homebrew, so we use mas-cli (Mac App Store CLI)
      - name: Install Transporter
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        run: |
          echo "üì¶ Installing Transporter..."

          # Check if Transporter is already installed
          if [ -d "/Applications/Transporter.app" ] && [ -f "/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter" ]; then
            echo "‚úÖ Transporter already installed"
            exit 0
          fi

          # Install mas-cli (Mac App Store command line tool) if not available
          if ! command -v mas &> /dev/null; then
            echo "Installing mas-cli..."
            brew install mas
          fi

          # Install Transporter from Mac App Store (App ID: 1450874784)
          echo "Installing Transporter from Mac App Store via mas-cli..."
          echo "Note: This may require App Store authentication in CI/CD"

          # Try to install Transporter
          if mas install 1450874784; then
            echo "‚úÖ Transporter installed successfully"
          else
            echo "‚ö†Ô∏è  Failed to install Transporter via mas-cli"
            echo "   This may require App Store sign-in in CI/CD environment"
            echo "   The upload script will try to find iTMSTransporter in alternative locations"
          fi

          # Wait a bit for installation to complete
          sleep 5

          # Verify installation
          if [ -d "/Applications/Transporter.app" ] && [ -f "/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter" ]; then
            echo "‚úÖ Transporter verified: /Applications/Transporter.app/Contents/itms/bin/iTMSTransporter"
          else
            echo "‚ö†Ô∏è  Transporter not found after installation attempt"
            echo "   The upload script will search for iTMSTransporter in:"
            echo "   - Xcode installation paths"
            echo "   - Common system directories"
            echo "   - This may fail if Transporter is not pre-installed on the runner"
          fi

      # Upload to App Store Connect - matches 'make upload' behavior
      # This script handles: .pkg creation, .pkg signing, .itmsp creation, and upload
      - name: Upload to App Store Connect (production releases)
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        env:
          TRANSPORTER_APPLE_ID: ${{ secrets.TRANSPORTER_APPLE_ID }}
          TRANSPORTER_PASSWORD: ${{ secrets.TRANSPORTER_PASSWORD }}
          APP_VERSION: ${{ steps.version.outputs.version }}
        timeout-minutes: 30
        run: |
          # Ensure keychain is accessible (upload_to_appstore.sh needs it)
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi

          # Check if Transporter credentials are configured
          if [ -z "$TRANSPORTER_APPLE_ID" ] || [ -z "$TRANSPORTER_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Transporter credentials not configured, skipping App Store Connect upload"
            echo "   The .itmsp package will be available as an artifact for manual upload"
            exit 0
          fi

          # Call upload_to_appstore.sh - matches 'make upload' behavior exactly
          # This script handles everything: .pkg creation, signing, .itmsp creation, and upload
          echo "üì§ Uploading to App Store Connect..."
          ./scripts/upload_to_appstore.sh

      # DMG creation is optional - only needed for testing or direct distribution
      # App Store distribution doesn't require DMG files
      - name: Create DMG (optional - for testing)
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          ./scripts/create_dmg.sh
        continue-on-error: true

      # DMG artifacts are optional - mainly for testing/backup
      # App Store distribution doesn't use DMG files
      - name: Rename DMG with architecture
        run: |
          cd export
          VERSION="${{ steps.version.outputs.version }}"
          if [ -f "Blackhole Sim-${VERSION}.dmg" ]; then
            mv "Blackhole Sim-${VERSION}.dmg" "Blackhole Sim-${VERSION}-${{ matrix.arch }}.dmg"
          fi
        continue-on-error: true

      - name: Upload DMG artifact (optional - for testing)
        uses: actions/upload-artifact@v4
        with:
          name: BlackholeSim-${{ steps.version.outputs.version }}-${{ matrix.arch }}-dmg
          path: export/Blackhole Sim-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg
          retention-days: 7
          if-no-files-found: warn
        continue-on-error: true

      - name: Upload .itmsp package artifact (App Store)
        if: github.ref_type == 'tag' && env.SIGNING_ENABLED == 'true' && matrix.arch == 'arm64'
        uses: actions/upload-artifact@v4
        with:
          name: BlackholeSim-${{ steps.version.outputs.version }}-appstore-itmsp
          path: export/Blackhole Sim.itmsp
          retention-days: 30
          if-no-files-found: error

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security delete-keychain "$KEYCHAIN_PATH" || true
            security list-keychain -d user -s login.keychain || true
          fi

      - name: Summary
        run: |
          echo "## Build Summary for ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Architecture: ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Triplet: ${{ matrix.triplet }}" >> $GITHUB_STEP_SUMMARY
          echo "- Runner: ${{ matrix.runner }}" >> $GITHUB_STEP_SUMMARY
          if [ "${SIGNING_ENABLED:-false}" = "true" ]; then
            echo "- ‚úÖ Code signed: Yes" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ö†Ô∏è Code signed: No (secrets not configured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Version: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.ref_type }}" = "tag" ] && [ "${SIGNING_ENABLED:-false}" = "true" ] && [ "${{ matrix.arch }}" = "arm64" ]; then
            echo "- üì¶ App Store: Blackhole Sim.itmsp (automatically uploaded)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -f "export/Blackhole Sim-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg" ]; then
            echo "- üíæ DMG: Created (available as artifact for testing)" >> $GITHUB_STEP_SUMMARY
          fi

  # GitHub Releases DISABLED - App Store distribution only
  # DMG files are not needed since the app is distributed via the App Store
  # The App Store handles versioning and distribution automatically
  #
  # upload-release:
  #   needs: build
  #   if: github.ref_type == 'tag' && startsWith(github.ref_name, 'prod-v')
  #   runs-on: macos-latest
  #   permissions:
  #     contents: write # Required to create/update releases and upload release assets
  #
  #   steps:
  #     - name: Extract version from tag
  #       id: version
  #       run: |
  #         if [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
  #           VERSION="${BASH_REMATCH[1]}"
  #           echo "version=$VERSION" >> $GITHUB_OUTPUT
  #           echo "‚úÖ Extracted version from tag: $VERSION"
  #         else
  #           echo "‚ùå Error: Tag format invalid"
  #           exit 1
  #         fi
  #
  #     - name: Download all artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         pattern: BlackholeSim-${{ steps.version.outputs.version }}-*-dmg
  #         merge-multiple: false
  #         path: release-assets
  #
  #     - name: Find and prepare DMG files
  #       run: |
  #         echo "Looking for DMG files in release-assets..."
  #         find release-assets -name "*.dmg" -type f
  #         # Count DMG files found
  #         DMG_COUNT=$(find release-assets -name "*.dmg" -type f | wc -l | tr -d ' ')
  #         echo "Found $DMG_COUNT DMG file(s)"
  #         if [ "$DMG_COUNT" -eq 0 ]; then
  #           echo "‚ùå Error: No DMG files found!"
  #           exit 1
  #         fi
  #
  #     - name: Upload release assets
  #       uses: softprops/action-gh-release@v1
  #       with:
  #         files: release-assets/**/*.dmg
  #         tag_name: ${{ github.ref_name }}
  #         name: Release ${{ steps.version.outputs.version }}
  #         draft: false
  #         prerelease: false
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
