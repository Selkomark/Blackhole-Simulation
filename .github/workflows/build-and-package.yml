name: Build and Package

# This workflow builds the Blackhole Simulation application for both Intel (x86_64) and Apple Silicon (arm64)
# architectures, creates DMG files, and uploads them as artifacts.
#
# Triggers:
#   - Push to main branch (uses default version 1.0) - uploads artifacts only
#   - Tags matching 'prod-v*' pattern (e.g., prod-v1.0.0) - extracts version from tag and uploads as release assets
#   - Manual workflow dispatch (can specify version via input)
#
# Version Handling:
#   - Tag format: prod-v<VERSION> (e.g., prod-v1.0.0 extracts version "1.0.0")
#   - Version is used in DMG filenames, app bundle Info.plist, and artifact names
#   - Default version for branch builds: 1.0
#
# Outputs:
#   - DMG files for each architecture (Blackhole Simulation-<VERSION>-<arch>.dmg)
#   - For tag pushes: DMG files are uploaded as release assets on GitHub Releases
#   - For branch pushes: DMG files are uploaded as workflow artifacts
#
# Note: Code signing is enabled if MACOS_CERTIFICATE and MACOS_CERTIFICATE_PASSWORD secrets are configured.
# To set up signing:
#   1. Export your Developer ID certificate as a .p12 file
#   2. Base64 encode it: base64 -i YourCertificate.p12 | pbcopy
#   3. Add it as a GitHub secret: MACOS_CERTIFICATE
#   4. Add the certificate password as another secret: MACOS_CERTIFICATE_PASSWORD
#
# Notarization is enabled for production releases (tags) if NOTARY_APPLE_ID, NOTARY_TEAM_ID, and NOTARY_PASSWORD secrets are configured.
# To set up notarization:
#   1. Create an app-specific password at https://appleid.apple.com
#   2. Add secrets:
#      - NOTARY_APPLE_ID: Your Apple ID email
#      - NOTARY_TEAM_ID: Your Team ID (e.g., "72583G5MNU")
#      - NOTARY_PASSWORD: App-specific password (not your regular password)
#   3. Notarization adds 5-15 minutes to build time but is required for distribution

on:
  push:
    # branches:
    #   - main
    tags:
      - "prod-v*" # Trigger on production tags like prod-v1.0.0
  workflow_dispatch: # Allow manual triggering
    inputs:
      version:
        description: "Version number (e.g., 1.0.0)"
        required: false
        type: string

jobs:
  build:
    strategy:
      matrix:
        # x86_64 builds are commented out to save time and cost
        # Uncomment the line below and the x86_64 include entry to enable Intel builds
        arch: [arm64] # , x86_64]
        include:
          - arch: arm64
            runner: macos-14
            triplet: arm64-osx
          # - arch: x86_64
          #   runner: macos-13
          #   triplet: x64-osx

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for tags

      - name: Extract version from tag
        id: version
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]] && [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
            # Extract version from tag (everything after prod-v)
            VERSION="${BASH_REMATCH[1]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Extracted version from tag: $VERSION"
          elif [[ -n "${{ inputs.version }}" ]]; then
            # Use version from workflow_dispatch input
            VERSION="${{ inputs.version }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Using version from input: $VERSION"
          else
            # Default version for branch builds
            VERSION="1.0"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Using default version: $VERSION"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set up environment
        run: |
          echo "ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "TRIPLET=${{ matrix.triplet }}" >> $GITHUB_ENV
          # Check which installation location vcpkg uses (manifest mode uses vcpkg_installed)
          if [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            echo "VCPKG_INSTALLED=./vcpkg_installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          else
            echo "VCPKG_INSTALLED=./vcpkg/installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          fi
          echo "APP_VERSION=${{ steps.version.outputs.version }}" >> $GITHUB_ENV

      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~/.cache/vcpkg
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json') }}-${{ matrix.triplet }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json') }}-
            ${{ runner.os }}-vcpkg-

      - name: Clone vcpkg
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: |
          git clone https://github.com/Microsoft/vcpkg.git vcpkg

      - name: Make scripts executable
        run: |
          chmod +x scripts/*.sh
          chmod +x sign_package.sh
          if [ -f "vcpkg/bootstrap-vcpkg.sh" ]; then
            chmod +x vcpkg/bootstrap-vcpkg.sh
          fi

      - name: Bootstrap vcpkg
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: |
          cd vcpkg
          ./bootstrap-vcpkg.sh

      - name: Cache vcpkg installed packages
        id: cache-vcpkg-installed
        uses: actions/cache@v4
        with:
          path: |
            vcpkg/installed/${{ matrix.triplet }}
            vcpkg_installed/${{ matrix.triplet }}
          key: ${{ runner.os }}-vcpkg-installed-${{ hashFiles('vcpkg.json') }}-${{ matrix.triplet }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-installed-${{ hashFiles('vcpkg.json') }}-
            ${{ runner.os }}-vcpkg-installed-
        continue-on-error: true

      - name: Cache vcpkg downloads
        id: cache-vcpkg-downloads
        uses: actions/cache@v4
        with:
          path: vcpkg/downloads
          key: ${{ runner.os }}-vcpkg-downloads-${{ hashFiles('vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-downloads-

      - name: Install build dependencies
        run: |
          # Install nasm required for ffmpeg build
          brew install nasm

      - name: Install dependencies
        run: |
          echo "Installing vcpkg packages for triplet: ${{ matrix.triplet }}"
          echo "Cache hit status: ${{ steps.cache-vcpkg-installed.outputs.cache-hit }}"
          echo "Checking vcpkg installation directory before install:"
          if [ -d "./vcpkg/installed" ]; then
            ls -la "./vcpkg/installed/" || true
            if [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
              echo "Triplet directory exists, checking contents:"
              ls -la "./vcpkg/installed/${{ matrix.triplet }}/" || true
            fi
          else
            echo "installed directory does not exist yet"
          fi

          # Ensure installed directory exists
          mkdir -p "./vcpkg/installed/${{ matrix.triplet }}"

          # Always run vcpkg install - it will skip already installed packages
          # but will install missing ones even if cache was restored
          echo "Running vcpkg install..."
          # Use manifest mode by running from project root (vcpkg.json is in root)
          if ! ./vcpkg/vcpkg install --triplet ${{ matrix.triplet }}; then
            echo "‚ùå Error: vcpkg install failed!"
            echo "Checking vcpkg installed directory:"
            ls -la "./vcpkg/installed/" || echo "installed directory does not exist"
            echo "Checking for alternative installation locations:"
            find . -type d -name "installed" 2>/dev/null | head -10 || true
            echo "Checking vcpkg packages directory:"
            ls -la "./vcpkg/packages/" 2>/dev/null | head -20 || true
            exit 1
          fi

          echo "‚úÖ vcpkg install completed successfully"
          echo "Checking installed directory after install:"
          echo "Current directory: $(pwd)"
          echo "Looking for installed directory:"
          ls -la "./vcpkg/" || true

          # Wait a moment for any background operations to complete
          sleep 2

          if [ -d "./vcpkg/installed" ]; then
            echo "Found installed directory, listing contents:"
            ls -la "./vcpkg/installed/" || true
          fi

          # Check if packages directory has the triplet (packages are built here first)
          if [ -d "./vcpkg/packages" ]; then
            echo "Checking packages directory:"
            ls -la "./vcpkg/packages/" | grep "${{ matrix.triplet }}" || true
          fi

          # Check both possible installation locations (vcpkg/installed and vcpkg_installed)
          INSTALLED_DIR=""
          if [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
            echo "‚úÖ Found triplet directory in vcpkg_installed (manifest mode)"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
            echo "‚úÖ Found triplet directory in vcpkg/installed"
          else
            echo "‚ö†Ô∏è  Triplet directory not found in either location, checking packages:"
            if [ -d "./vcpkg/packages" ]; then
              echo "Packages directory exists, checking for installed packages:"
              find "./vcpkg/packages" -maxdepth 1 -type d -name "*_${{ matrix.triplet }}" | head -5 || true
            fi
            echo "Checking for vcpkg_installed directory:"
            ls -la "./vcpkg_installed/" 2>/dev/null || echo "vcpkg_installed does not exist"
            echo "Checking for vcpkg/installed directory:"
            ls -la "./vcpkg/installed/" 2>/dev/null || echo "vcpkg/installed does not exist"
            echo "‚ùå ERROR: Triplet directory not found in either location!"
            echo "Searching for triplet directory in alternative locations:"
            find . -type d -name "${{ matrix.triplet }}" 2>/dev/null | head -10 || true
            echo "Checking vcpkg root structure:"
            find ./vcpkg -maxdepth 3 -type d | head -20 || true
            exit 1
          fi

          # Display contents of found directory
          if [ -n "$INSTALLED_DIR" ]; then
            echo "Installed directory: $INSTALLED_DIR"
            ls -la "$INSTALLED_DIR/" || true
            echo "Package count:"
            find "$INSTALLED_DIR" -name "*.pc" -o -name "*.cmake" | wc -l || true
            # Update environment variable if using vcpkg_installed
            if [[ "$INSTALLED_DIR" == "./vcpkg_installed"* ]]; then
              echo "VCPKG_INSTALLED=$INSTALLED_DIR" >> $GITHUB_ENV
            fi
          fi

      - name: Verify vcpkg installation
        run: |
          echo "Verifying vcpkg installation for ${{ matrix.triplet }}..."

          # Determine installed directory (use environment variable if set, otherwise check both locations)
          if [ -n "$VCPKG_INSTALLED" ]; then
            INSTALLED_DIR="$VCPKG_INSTALLED"
          elif [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
          else
            echo "‚ùå Error: vcpkg installed directory for triplet ${{ matrix.triplet }} not found!"
            echo "Checking both possible locations:"
            ls -la "./vcpkg/installed/" 2>/dev/null || echo "vcpkg/installed does not exist"
            ls -la "./vcpkg_installed/" 2>/dev/null || echo "vcpkg_installed does not exist"
            exit 1
          fi

          echo "‚úÖ Installed directory exists: $INSTALLED_DIR"

          # Check for SDL2 headers
          if [ ! -f "$INSTALLED_DIR/include/SDL2/SDL.h" ]; then
            echo "‚ùå Error: SDL2 headers not found!"
            echo "Checking include directory contents:"
            ls -la "$INSTALLED_DIR/include/" || true
            if [ -d "$INSTALLED_DIR/include" ]; then
              echo "Subdirectories in include:"
              find "$INSTALLED_DIR/include" -maxdepth 2 -type d | head -20
            fi
            exit 1
          fi

          echo "‚úÖ SDL2 headers found at: $INSTALLED_DIR/include/SDL2/SDL.h"
          echo "VCPKG_INSTALLED=$INSTALLED_DIR" >> $GITHUB_ENV

      - name: Update Makefile for architecture
        run: |
          # Determine installed directory (use environment variable if set, otherwise check both locations)
          if [ -n "$VCPKG_INSTALLED" ]; then
            INSTALLED_DIR="$VCPKG_INSTALLED"
          elif [ -d "./vcpkg_installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg_installed/${{ matrix.triplet }}"
          elif [ -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            INSTALLED_DIR="./vcpkg/installed/${{ matrix.triplet }}"
          else
            echo "‚ùå Error: Could not determine vcpkg installed directory!"
            exit 1
          fi

          # Update VCPKG_INSTALLED path in Makefile (macOS sed syntax)
          sed -i '' "s|VCPKG_INSTALLED := .*|VCPKG_INSTALLED := $INSTALLED_DIR|" Makefile
          # Update RPATH (escape slashes for sed)
          INSTALLED_DIR_ESCAPED=$(echo "$INSTALLED_DIR" | sed 's|/|\\/|g')
          sed -i '' "s|-Wl,-rpath,\\./vcpkg/installed/[^ ]*|-Wl,-rpath,$INSTALLED_DIR/lib|" Makefile
          sed -i '' "s|-Wl,-rpath,\\./vcpkg_installed/[^ ]*|-Wl,-rpath,$INSTALLED_DIR/lib|" Makefile
          echo "Updated Makefile for ${{ matrix.triplet }}"
          echo "VCPKG_INSTALLED path: $INSTALLED_DIR"
          echo "VCPKG_INSTALLED in Makefile:"
          grep "VCPKG_INSTALLED" Makefile
          echo "Include path:"
          grep "INCLUDES" Makefile

      - name: Cache build artifacts
        id: cache-build
        uses: actions/cache@v4
        with:
          path: |
            build
            export/blackhole_sim
          key: ${{ runner.os }}-build-${{ matrix.arch }}-${{ hashFiles('Makefile', 'src/**/*.cpp', 'src/**/*.mm', 'include/**/*.hpp', 'shaders/**/*.metal') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ matrix.arch }}-

      - name: Build application
        env:
          ARCH: ${{ matrix.arch }}
        run: |
          # Only clean if cache miss to speed up builds
          if [ "${{ steps.cache-build.outputs.cache-hit }}" != "true" ]; then
            echo "Cache miss - cleaning build directory"
            make clean
          else
            echo "Cache hit - skipping clean for faster build"
          fi
          make

      - name: Create app bundle
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          make app

      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Check if secrets are configured
          if [ -z "$MACOS_CERTIFICATE" ] || [ -z "$MACOS_CERTIFICATE_PASSWORD" ]; then
            echo "‚ö†Ô∏è  Signing secrets not configured, skipping code signing"
            exit 0
          fi

          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Allow codesign to access the certificate
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" $KEYCHAIN_PATH

          # Find and export the signing identity
          IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | \
            grep "Developer ID Application" | \
            head -1 | \
            sed -n 's/.*"\(.*\)".*/\1/p')

          if [ -z "$IDENTITY" ]; then
            echo "‚ùå Error: Could not find Developer ID Application certificate"
            security list-keychain -d user -s login.keychain
            exit 1
          fi

          echo "‚úÖ Found signing identity: $IDENTITY"
          echo "MACOS_SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "$KEYCHAIN_PATH" > $RUNNER_TEMP/keychain_path.txt
          echo "SIGNING_ENABLED=true" >> $GITHUB_ENV

      - name: Sign app bundle
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_SIGNING_IDENTITY: ${{ env.MACOS_SIGNING_IDENTITY }}
        run: |
          # Ensure keychain is accessible for signing
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi
          ./scripts/sign_app.sh

      - name: Notarize app bundle
        if: env.SIGNING_ENABLED == 'true' && github.ref_type == 'tag' && secrets.NOTARY_APPLE_ID != ''
        env:
          NOTARY_APPLE_ID: ${{ secrets.NOTARY_APPLE_ID }}
          NOTARY_TEAM_ID: ${{ secrets.NOTARY_TEAM_ID }}
          NOTARY_PASSWORD: ${{ secrets.NOTARY_PASSWORD }}
        timeout-minutes: 20
        run: |
          echo "üöÄ Starting notarization (production release)..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚è±Ô∏è  Notarization typically takes 5-15 minutes"
          echo "   This is Apple's server-side security scan - cannot be sped up"
          echo "   The workflow will wait automatically..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          ./scripts/notarize_app.sh
          echo "‚úÖ Notarization complete"

      - name: Create DMG
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          ./scripts/create_dmg.sh

      - name: Rename DMG with architecture
        run: |
          cd export
          VERSION="${{ steps.version.outputs.version }}"
          if [ -f "Blackhole Simulation-${VERSION}.dmg" ]; then
            mv "Blackhole Simulation-${VERSION}.dmg" "Blackhole Simulation-${VERSION}-${{ matrix.arch }}.dmg"
          fi

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: BlackholeSimulation-${{ steps.version.outputs.version }}-${{ matrix.arch }}-dmg
          path: export/Blackhole Simulation-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg
          retention-days: 30
          if-no-files-found: error

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security delete-keychain "$KEYCHAIN_PATH" || true
            security list-keychain -d user -s login.keychain || true
          fi

      - name: Summary
        run: |
          echo "## Build Summary for ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Architecture: ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Triplet: ${{ matrix.triplet }}" >> $GITHUB_STEP_SUMMARY
          echo "- Runner: ${{ matrix.runner }}" >> $GITHUB_STEP_SUMMARY
          if [ "${SIGNING_ENABLED:-false}" = "true" ]; then
            echo "- ‚úÖ Code signed: Yes" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ö†Ô∏è Code signed: No (secrets not configured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Version: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- DMG: Blackhole Simulation-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg" >> $GITHUB_STEP_SUMMARY

  # Upload release assets when triggered by a tag
  upload-release:
    needs: build
    if: github.ref_type == 'tag' && startsWith(github.ref_name, 'prod-v')
    runs-on: macos-latest
    permissions:
      contents: write # Required to create/update releases and upload release assets

    steps:
      - name: Extract version from tag
        id: version
        run: |
          if [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "‚úÖ Extracted version from tag: $VERSION"
          else
            echo "‚ùå Error: Tag format invalid"
            exit 1
          fi

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: BlackholeSimulation-${{ steps.version.outputs.version }}-*-dmg
          merge-multiple: false
          path: release-assets

      - name: Find and prepare DMG files
        run: |
          echo "Looking for DMG files in release-assets..."
          find release-assets -name "*.dmg" -type f
          # Count DMG files found
          DMG_COUNT=$(find release-assets -name "*.dmg" -type f | wc -l | tr -d ' ')
          echo "Found $DMG_COUNT DMG file(s)"
          if [ "$DMG_COUNT" -eq 0 ]; then
            echo "‚ùå Error: No DMG files found!"
            exit 1
          fi

      - name: Upload release assets
        uses: softprops/action-gh-release@v1
        with:
          files: release-assets/**/*.dmg
          tag_name: ${{ github.ref_name }}
          name: Release ${{ steps.version.outputs.version }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
