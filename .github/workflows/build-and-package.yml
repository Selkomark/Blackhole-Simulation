name: Build and Package

# This workflow builds the Blackhole Simulation application for both Intel (x86_64) and Apple Silicon (arm64)
# architectures, creates DMG files, and uploads them as artifacts.
#
# Triggers:
#   - Push to main branch (uses default version 1.0)
#   - Tags matching 'prod-v*' pattern (e.g., prod-v1.0.0) - extracts version from tag
#   - Manual workflow dispatch (can specify version via input)
#
# Version Handling:
#   - Tag format: prod-v<VERSION> (e.g., prod-v1.0.0 extracts version "1.0.0")
#   - Version is used in DMG filenames, app bundle Info.plist, and artifact names
#   - Default version for branch builds: 1.0
#
# Outputs:
#   - DMG files for each architecture (Blackhole Simulation-<VERSION>-<arch>.dmg)
#
# Note: Code signing is enabled if MACOS_CERTIFICATE and MACOS_CERTIFICATE_PASSWORD secrets are configured.
# To set up signing:
#   1. Export your Developer ID certificate as a .p12 file
#   2. Base64 encode it: base64 -i YourCertificate.p12 | pbcopy
#   3. Add it as a GitHub secret: MACOS_CERTIFICATE
#   4. Add the certificate password as another secret: MACOS_CERTIFICATE_PASSWORD

on:
  push:
    branches:
      - main
    tags:
      - 'prod-v*'  # Trigger on production tags like prod-v1.0.0
  workflow_dispatch: # Allow manual triggering
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: false
        type: string

jobs:
  build:
    strategy:
      matrix:
        arch: [arm64, x86_64]
        include:
          - arch: arm64
            runner: macos-14
            triplet: arm64-osx
          - arch: x86_64
            runner: macos-13
            triplet: x64-osx
    
    runs-on: ${{ matrix.runner }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for tags
      
      - name: Extract version from tag
        id: version
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]] && [[ "${{ github.ref_name }}" =~ ^prod-v(.+)$ ]]; then
            # Extract version from tag (everything after prod-v)
            VERSION="${BASH_REMATCH[1]}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "✅ Extracted version from tag: $VERSION"
          elif [[ -n "${{ inputs.version }}" ]]; then
            # Use version from workflow_dispatch input
            VERSION="${{ inputs.version }}"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "✅ Using version from input: $VERSION"
          else
            # Default version for branch builds
            VERSION="1.0"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "⚠️  Using default version: $VERSION"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      
      - name: Set up environment
        run: |
          echo "ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "TRIPLET=${{ matrix.triplet }}" >> $GITHUB_ENV
          echo "VCPKG_INSTALLED=./vcpkg/installed/${{ matrix.triplet }}" >> $GITHUB_ENV
          echo "APP_VERSION=${{ steps.version.outputs.version }}" >> $GITHUB_ENV
      
      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v4
        with:
          path: |
            vcpkg
            ~/.cache/vcpkg
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json') }}-${{ matrix.triplet }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json') }}-
            ${{ runner.os }}-vcpkg-
      
      - name: Clone vcpkg
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: |
          git clone https://github.com/Microsoft/vcpkg.git vcpkg
      
      - name: Make scripts executable
        run: |
          chmod +x scripts/*.sh
          chmod +x sign_package.sh
          if [ -f "vcpkg/bootstrap-vcpkg.sh" ]; then
            chmod +x vcpkg/bootstrap-vcpkg.sh
          fi
      
      - name: Bootstrap vcpkg
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        run: |
          cd vcpkg
          ./bootstrap-vcpkg.sh
      
      - name: Cache vcpkg installed packages
        id: cache-vcpkg-installed
        uses: actions/cache@v4
        with:
          path: vcpkg/installed/${{ matrix.triplet }}
          key: ${{ runner.os }}-vcpkg-installed-${{ hashFiles('vcpkg.json') }}-${{ matrix.triplet }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-installed-${{ hashFiles('vcpkg.json') }}-
            ${{ runner.os }}-vcpkg-installed-
      
      - name: Cache vcpkg downloads
        id: cache-vcpkg-downloads
        uses: actions/cache@v4
        with:
          path: vcpkg/downloads
          key: ${{ runner.os }}-vcpkg-downloads-${{ hashFiles('vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-downloads-
      
      - name: Install build dependencies
        run: |
          # Install nasm required for ffmpeg build
          brew install nasm
      
      - name: Install dependencies
        run: |
          ./vcpkg/vcpkg install --triplet ${{ matrix.triplet }}
          # Verify installation succeeded
          if [ $? -ne 0 ]; then
            echo "❌ Error: vcpkg install failed!"
            exit 1
          fi
          echo "✅ vcpkg install completed successfully"
      
      - name: Verify vcpkg installation
        run: |
          echo "Verifying vcpkg installation for ${{ matrix.triplet }}..."
          if [ ! -d "./vcpkg/installed/${{ matrix.triplet }}" ]; then
            echo "❌ Error: vcpkg installed directory not found!"
            exit 1
          fi
          if [ ! -f "./vcpkg/installed/${{ matrix.triplet }}/include/SDL2/SDL.h" ]; then
            echo "❌ Error: SDL2 headers not found!"
            echo "Checking include directory contents:"
            ls -la "./vcpkg/installed/${{ matrix.triplet }}/include/" || true
            exit 1
          fi
          echo "✅ SDL2 headers found at: ./vcpkg/installed/${{ matrix.triplet }}/include/SDL2/SDL.h"
      
      - name: Update Makefile for architecture
        run: |
          # Update VCPKG_INSTALLED path in Makefile (macOS sed syntax)
          sed -i '' "s|VCPKG_INSTALLED := .*|VCPKG_INSTALLED := ./vcpkg/installed/${{ matrix.triplet }}|" Makefile
          # Update RPATH
          sed -i '' "s|-Wl,-rpath,\\./vcpkg/installed/[^ ]*|-Wl,-rpath,./vcpkg/installed/${{ matrix.triplet }}/lib|" Makefile
          echo "Updated Makefile for ${{ matrix.triplet }}"
          echo "VCPKG_INSTALLED path:"
          grep "VCPKG_INSTALLED" Makefile
          echo "Include path:"
          grep "INCLUDES" Makefile
      
      - name: Cache build artifacts
        id: cache-build
        uses: actions/cache@v4
        with:
          path: |
            build
            export/blackhole_sim
          key: ${{ runner.os }}-build-${{ matrix.arch }}-${{ hashFiles('Makefile', 'src/**/*.cpp', 'src/**/*.mm', 'include/**/*.hpp', 'shaders/**/*.metal') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ matrix.arch }}-
      
      - name: Build application
        env:
          ARCH: ${{ matrix.arch }}
        run: |
          # Only clean if cache miss to speed up builds
          if [ "${{ steps.cache-build.outputs.cache-hit }}" != "true" ]; then
            echo "Cache miss - cleaning build directory"
            make clean
          else
            echo "Cache hit - skipping clean for faster build"
          fi
          make
      
      - name: Create app bundle
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          make app
      
      - name: Import signing certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          # Check if secrets are configured
          if [ -z "$MACOS_CERTIFICATE" ] || [ -z "$MACOS_CERTIFICATE_PASSWORD" ]; then
            echo "⚠️  Signing secrets not configured, skipping code signing"
            exit 0
          fi
          
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          # Decode certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > $CERTIFICATE_PATH
          
          # Create temporary keychain
          security create-keychain -p "" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "" $KEYCHAIN_PATH
          
          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # Allow codesign to access the certificate
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" $KEYCHAIN_PATH
          
          # Find and export the signing identity
          IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | \
            grep "Developer ID Application" | \
            head -1 | \
            sed -n 's/.*"\(.*\)".*/\1/p')
          
          if [ -z "$IDENTITY" ]; then
            echo "❌ Error: Could not find Developer ID Application certificate"
            security list-keychain -d user -s login.keychain
            exit 1
          fi
          
          echo "✅ Found signing identity: $IDENTITY"
          echo "MACOS_SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "$KEYCHAIN_PATH" > $RUNNER_TEMP/keychain_path.txt
          echo "SIGNING_ENABLED=true" >> $GITHUB_ENV
      
      - name: Sign app bundle
        if: env.SIGNING_ENABLED == 'true'
        env:
          MACOS_SIGNING_IDENTITY: ${{ env.MACOS_SIGNING_IDENTITY }}
        run: |
          # Ensure keychain is accessible for signing
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security list-keychain -d user -s "$KEYCHAIN_PATH" login.keychain
            security unlock-keychain -p "" "$KEYCHAIN_PATH"
          fi
          ./scripts/sign_app.sh
      
      - name: Create DMG
        env:
          APP_VERSION: ${{ steps.version.outputs.version }}
        run: |
          ./scripts/create_dmg.sh
      
      - name: Rename DMG with architecture
        run: |
          cd export
          VERSION="${{ steps.version.outputs.version }}"
          if [ -f "Blackhole Simulation-${VERSION}.dmg" ]; then
            mv "Blackhole Simulation-${VERSION}.dmg" "Blackhole Simulation-${VERSION}-${{ matrix.arch }}.dmg"
          fi
      
      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: BlackholeSimulation-${{ steps.version.outputs.version }}-${{ matrix.arch }}-dmg
          path: export/Blackhole Simulation-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg
          retention-days: 30
          if-no-files-found: error
      
      - name: Cleanup keychain
        if: always()
        run: |
          if [ -f $RUNNER_TEMP/keychain_path.txt ]; then
            KEYCHAIN_PATH=$(cat $RUNNER_TEMP/keychain_path.txt)
            security delete-keychain "$KEYCHAIN_PATH" || true
            security list-keychain -d user -s login.keychain || true
          fi
      
      - name: Summary
        run: |
          echo "## Build Summary for ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Architecture: ${{ matrix.arch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Triplet: ${{ matrix.triplet }}" >> $GITHUB_STEP_SUMMARY
          echo "- Runner: ${{ matrix.runner }}" >> $GITHUB_STEP_SUMMARY
          if [ "${SIGNING_ENABLED:-false}" = "true" ]; then
            echo "- ✅ Code signed: Yes" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ⚠️ Code signed: No (secrets not configured)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Version: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- DMG: Blackhole Simulation-${{ steps.version.outputs.version }}-${{ matrix.arch }}.dmg" >> $GITHUB_STEP_SUMMARY

